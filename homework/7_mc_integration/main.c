#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include"func.h"
#include <complex.h>
#define R 0.9

double f(int dim, double* p){
	assert(dim==2);
	double x = p[0];
	double y = p[1];
	if(x*x+y*y<R*R){
		return 1;
	}
	else{
		return 0;
	}
}

double fn(int dim, double* p){
	assert(dim==2);
	double x = p[0];
	double y = p[1];
	return 1/sqrt(x*y);
}

double fm(int dim, double *p){
	assert(dim==3);
	double x = p[0];
	double y = p[1];
	double z = p[2];
	if(1-cos(x)*cos(y)*cos(z)==0){
		return 10;
	}
	else{
		return pow(M_PI,-3)*pow(1-cos(x)*cos(y)*cos(z),-1);
	}
}

int main(int argc, char** argv){
	double aa[] = {0,0,0};
	double bb[] = {M_PI,M_PI,M_PI};
	int dim1 = sizeof(aa)/sizeof(aa[0]);
if(argc>1){
	srand(42);
	int N = (int)atof(argv[1]);
	complex result_plain = plainmontecarlo(dim1,fm,aa,bb,N);
	double integ_plain = creal(result_plain);
  	double exact = 1.3932039296856768591842462603255;
	double err_plain = fabs(integ_plain-exact);
	complex result_quasi = quasimontecarlo(dim1,fm,aa,bb,N);
	double integ_quasi = creal(result_quasi);
	double err_quasi = fabs(integ_quasi-exact);
	printf("%i %g %g\n",N,err_plain,err_quasi);
}
else{
	double a[] = {0,0};
	double b[] = {1,1};
	double dim = sizeof(a)/sizeof(a[0]);
	int N = 1e6;
	complex result_plain = plainmontecarlo(dim,f,a,b,N);
	double integ_plain = creal(result_plain);
	double est_err_plain = cimag(result_plain);
	double exact = M_PI/4*R*R;
	double error_plain = fabs(integ_plain-exact);
	printf("Task A+B:\n\n");
	printf("Integration of x*x+y*y<0.9*0.9 (1 inside circle of R=0.9 and 0 outside) from 0 to 1 in both x and y with N=%i:\n",N);
	printf("Exact = %f\n",exact);
	printf("Pseudo-random:\n");
	printf("Integral = %f\n",integ_plain);
	printf("Error estimate = %f\n",est_err_plain);
	printf("Actual error = %f\n",error_plain);
	complex result_quasi = quasimontecarlo(dim,f,a,b,N);
	double integ_quasi = creal(result_quasi);
	double est_err_quasi = cimag(result_quasi);
	double error_quasi = fabs(integ_quasi-exact);
	printf("Quasi-random:\n");
	printf("Integral = %f\n",integ_quasi);
	printf("Error estimate = %f\n",est_err_quasi);
	printf("Actual error = %f\n\n",error_quasi);

	result_plain = plainmontecarlo(dim,fn,a,b,N);
	integ_plain = creal(result_plain);
	est_err_plain = cimag(result_plain);
	exact = 4;
	error_plain = fabs(integ_plain-exact);
	printf("Integration of 1/sqrt(x*y) from 0 to 1 in both x and y with N=%i:\n",N);
	printf("Exact = %f\n",exact);
	printf("Pseudo-random:\n");
	printf("Integral = %f\n",integ_plain);
	printf("Error estimate = %f\n",est_err_plain);
	printf("Actual error = %f\n",error_plain);
	result_quasi = quasimontecarlo(dim,fn,a,b,N);
	integ_quasi = creal(result_quasi);
	est_err_quasi = cimag(result_quasi);
	error_quasi = fabs(integ_quasi-exact);
	printf("Quasi-random:\n");
	printf("Integral = %f\n",integ_quasi);
	printf("Error estimate = %f\n",est_err_quasi);
	printf("Actual error = %f\n\n",error_quasi);

	result_plain = plainmontecarlo(dim1,fm,aa,bb,N);
	integ_plain = creal(result_plain);
	est_err_plain = cimag(result_plain);
	exact = 1.3932039296856768591842462603255;
	error_plain = fabs(integ_plain-exact);
	printf("Integration of (1/pi^3)*(1/(1-cos(x)*cos(y)*cos(z))) from 0 to pi in both x,y and z with N=%i:\n",N);
	printf("Exact = %f\n",exact);
	printf("Pseudo-random:\n");
	printf("Integral = %f\n",integ_plain);
	printf("Error estimate = %f\n",est_err_plain);
	printf("Actual error = %f\n",error_plain);
	result_quasi = quasimontecarlo(dim1,fm,aa,bb,N);
	integ_quasi = creal(result_quasi);
	est_err_quasi = cimag(result_quasi);
	error_quasi = fabs(integ_quasi-exact);
	printf("Quasi-random:\n");
	printf("Integral = %f\n",integ_quasi);
	printf("Error estimate = %f\n",est_err_quasi);
	printf("Actual error = %f\n\n",error_quasi);

	printf("The error comparison of the pseudo-random and quasi-random Monete carlo integrator is seen in error.plot.png for the integral (1/pi^3)*(1/(1-cos(x)*cos(y)*cos(z))). For some reason, the data generated by the pseudo-random MC integrator on my computer produces these quick jumps once in a while and I don't know why. However there is still a trend that the error decreases faster for the quasi-random MC integrator as a function of N than the pseudo-random MC integrator.");
}
}
